/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package lznp.lzip;

import java.util.Arrays;
import java.util.HashMap;
import lznp.huffman.HuffmanTree;
import lznp.util.BitStream;
import lznp.util.LZNFFile;
import lznp.util.Utils;

/**
 *
 * @author /u/Philboyd_Studge
 */
public class Decompress
{
    private final BitStream treeStream;
    private final BitStream bitStream;
    private byte[] inStream;
    private byte[] outStream;
    
    private HashMap<Integer, Integer> hashTable;
    
    public Decompress(LZNFFile inFile)
    {
        treeStream = inFile.getTreeStream();
        //System.out.println("after=======");
        //System.out.println(treeStream);
        bitStream = inFile.getBitStream();       
        inStream = new byte[inFile.getHeader().getFileLength()];  
        hashTable = new HashMap<>();
    }
    
    public byte[] getOutstream() { return outStream; }
    
    public void decompress()
    {
        decodeHuffman();
        decode();
    }
    
    public void decode()
    {
        outStream = new byte[inStream.length * 4];
        
        int matchLen;
        int current = 0;
        int outPointer = 0;
        int pointer;
        
        for (int i = 0; i < 3; i++)
        {
            outStream[i] = inStream[i];
            current++;
            outPointer++;
        }
        
        while (current < inStream.length)
        {
            byte[] contextBytes = { outStream[outPointer - 3], outStream[outPointer - 2], outStream[outPointer - 1] };
            int context = Utils.byteToInt(contextBytes);
            if (hashTable.containsKey(context))
            {
                pointer = hashTable.get(context);
            }
            else
            {
                pointer = 0;
            }
            hashTable.put(context, outPointer);
            
            if (pointer > 0)
            {
                matchLen = (int) (inStream[current] & 0xff);
                if (matchLen == 255)
                {
                    int lenCount = 1;
                    int nextLen = matchLen;
                    while (nextLen == 255)
                    {
                        nextLen = (int) inStream[current + lenCount] & 0xff;
                        matchLen += nextLen;
                        lenCount++;
                    }
                    current += lenCount - 1;
                }
                
                while (matchLen > 0)
                {
                    outStream[outPointer] = outStream[pointer];
                    pointer++;
                    outPointer++;
                    matchLen--;
                }
                current++;
                if (current >= inStream.length) break;
                outStream[outPointer] = inStream[current];
                outPointer++;
                current++;
            }
            outStream[outPointer] = inStream[current];
            outPointer++;
            current++;            
        }
        outStream = Arrays.copyOfRange(outStream, 0, outPointer);
    }
    
    public void decodeHuffman()
    {
        HuffmanTree ht = new HuffmanTree(treeStream);
        int current = 0;
        while (!bitStream.EOB())
        {
            inStream[current] = (byte) (ht.getCode(bitStream) & 0xff);
            System.out.println(inStream[current]);
            current++;
        }
        
        //trim
        inStream = Arrays.copyOf(inStream, current);
    }
}
